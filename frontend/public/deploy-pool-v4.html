<!DOCTYPE html>
<html>
<head>
  <title>Deploy Pool V4</title>
  <style>
    body { font-family: system-ui; background: #1a1a2e; color: #eee; padding: 40px; max-width: 800px; margin: 0 auto; }
    h1 { color: #f7931a; }
    button { background: #f7931a; color: #000; border: none; padding: 15px 30px; font-size: 18px; cursor: pointer; border-radius: 8px; margin: 10px 5px; }
    button:hover { background: #ffa500; }
    pre { background: #16213e; padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 11px; max-height: 400px; overflow-y: auto; white-space: pre-wrap; }
    .status { padding: 15px; border-radius: 8px; margin: 15px 0; }
    .success { background: #1a4d2e; border: 1px solid #2ecc71; }
    .error { background: #4d1a1a; border: 1px solid #e74c3c; }
    .pending { background: #4d4d1a; border: 1px solid #f1c40f; }
    .info { background: #1a3d4d; padding: 15px; border-radius: 8px; margin: 15px 0; }
  </style>
</head>
<body>
  <h1>üöÄ Deploy Pool V4 Contract</h1>
  
  <div class="info">
    <h3>New Features in V4:</h3>
    <ul>
      <li>‚úÖ <strong>LP Shares</strong> - Track liquidity provider ownership</li>
      <li>‚úÖ <strong>Add Liquidity</strong> - Anyone can add liquidity</li>
      <li>‚úÖ <strong>Remove Liquidity</strong> - Withdraw your share anytime</li>
      <li>‚úÖ Bidirectional swaps (swap-x-for-y AND swap-y-for-x)</li>
      <li>‚úÖ Skip fee transfer when sender == fee recipient</li>
    </ul>
  </div>

  <button id="deployBtn">Deploy Pool V4 Contract</button>
  
  <div id="status"></div>
  <pre id="output">Click "Deploy Pool V4 Contract" to begin...</pre>

  <script>
    const CONTRACT_SOURCE = `;; STACKS DEX - Pool Contract V4 (Clarity 3)
;; Features: Bidirectional swaps, LP shares, add/remove liquidity

(use-trait ft-trait 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)

;; Fee configuration: 30 basis points = 0.30%
(define-constant FEE_BPS u30)
(define-constant BPS_DENOM u10000)
(define-constant MINIMUM_LIQUIDITY u1000)

;; Error codes
(define-constant ERR_ZERO_INPUT (err u100))
(define-constant ERR_ZERO_RESERVES (err u101))
(define-constant ERR_DEADLINE_EXPIRED (err u102))
(define-constant ERR_SLIPPAGE_EXCEEDED (err u103))
(define-constant ERR_INSUFFICIENT_LIQUIDITY (err u104))
(define-constant ERR_TRANSFER_X_FAILED (err u105))
(define-constant ERR_TRANSFER_Y_FAILED (err u106))
(define-constant ERR_FEE_TRANSFER_FAILED (err u107))
(define-constant ERR_ALREADY_INITIALIZED (err u200))
(define-constant ERR_NOT_INITIALIZED (err u201))
(define-constant ERR_INSUFFICIENT_LP_BALANCE (err u202))
(define-constant ERR_ZERO_SHARES (err u203))
(define-constant ERR_MIN_LIQUIDITY (err u204))

;; State variables
(define-data-var fee-recipient (optional principal) none)
(define-data-var reserve-x uint u0)
(define-data-var reserve-y uint u0)
(define-data-var total-supply uint u0)
(define-data-var total-fees-x uint u0)
(define-data-var total-fees-y uint u0)

;; LP share balances
(define-map lp-balances principal uint)

;; Read-only functions
(define-read-only (get-reserves)
  { x: (var-get reserve-x), y: (var-get reserve-y) })

(define-read-only (get-fee-info)
  { fee-bps: FEE_BPS, denom: BPS_DENOM, recipient: (var-get fee-recipient) })

(define-read-only (get-total-fees)
  { fees-x: (var-get total-fees-x), fees-y: (var-get total-fees-y) })

(define-read-only (get-total-supply)
  (var-get total-supply))

(define-read-only (get-lp-balance (user principal))
  (default-to u0 (map-get? lp-balances user)))

(define-read-only (get-pool-share (user principal))
  (let ((balance (get-lp-balance user))
        (supply (var-get total-supply)))
    (if (is-eq supply u0)
      u0
      (/ (* balance u10000) supply))))

(define-read-only (get-user-liquidity (user principal))
  (let ((balance (get-lp-balance user))
        (supply (var-get total-supply))
        (rx (var-get reserve-x))
        (ry (var-get reserve-y)))
    (if (or (is-eq supply u0) (is-eq balance u0))
      { x: u0, y: u0, shares: u0 }
      { x: (/ (* balance rx) supply), 
        y: (/ (* balance ry) supply), 
        shares: balance })))

(define-read-only (quote-x-for-y (dx uint))
  (let ((rx (var-get reserve-x)) (ry (var-get reserve-y)))
    (asserts! (> dx u0) ERR_ZERO_INPUT)
    (asserts! (and (> rx u0) (> ry u0)) ERR_ZERO_RESERVES)
    (let ((fee (/ (* dx FEE_BPS) BPS_DENOM))
          (dx-to-pool (- dx fee))
          (dy (/ (* ry dx-to-pool) (+ rx dx-to-pool))))
      (asserts! (< dy ry) ERR_INSUFFICIENT_LIQUIDITY)
      (ok { dy: dy, fee: fee }))))

(define-read-only (quote-y-for-x (dy uint))
  (let ((rx (var-get reserve-x)) (ry (var-get reserve-y)))
    (asserts! (> dy u0) ERR_ZERO_INPUT)
    (asserts! (and (> rx u0) (> ry u0)) ERR_ZERO_RESERVES)
    (let ((fee (/ (* dy FEE_BPS) BPS_DENOM))
          (dy-to-pool (- dy fee))
          (dx (/ (* rx dy-to-pool) (+ ry dy-to-pool))))
      (asserts! (< dx rx) ERR_INSUFFICIENT_LIQUIDITY)
      (ok { dx: dx, fee: fee }))))

(define-read-only (quote-add-liquidity (amount-x uint) (amount-y uint))
  (let ((rx (var-get reserve-x))
        (ry (var-get reserve-y))
        (supply (var-get total-supply)))
    (if (is-eq supply u0)
      (ok { shares: (sqrti (* amount-x amount-y)), optimal-x: amount-x, optimal-y: amount-y })
      (let ((shares-from-x (/ (* amount-x supply) rx))
            (shares-from-y (/ (* amount-y supply) ry))
            (shares (if (< shares-from-x shares-from-y) shares-from-x shares-from-y))
            (optimal-x (/ (* shares rx) supply))
            (optimal-y (/ (* shares ry) supply)))
        (ok { shares: shares, optimal-x: optimal-x, optimal-y: optimal-y })))))

(define-read-only (quote-remove-liquidity (shares uint))
  (let ((supply (var-get total-supply))
        (rx (var-get reserve-x))
        (ry (var-get reserve-y)))
    (asserts! (> supply u0) ERR_NOT_INITIALIZED)
    (asserts! (> shares u0) ERR_ZERO_INPUT)
    (ok { 
      amount-x: (/ (* shares rx) supply),
      amount-y: (/ (* shares ry) supply)
    })))

(define-read-only (sqrti (n uint))
  (if (<= n u1)
    n
    (let ((x (/ (+ n u1) u2)))
      (sqrti-iter n x (/ (+ x (/ n x)) u2)))))

(define-read-only (sqrti-iter (n uint) (x uint) (x1 uint))
  (if (>= x1 x)
    x
    (sqrti-iter n x1 (/ (+ x1 (/ n x1)) u2))))

(define-public (swap-x-for-y 
    (token-x <ft-trait>)
    (token-y <ft-trait>)
    (dx uint)
    (min-dy uint)
    (recipient principal)
    (deadline uint))
  (let ((rx (var-get reserve-x))
        (ry (var-get reserve-y))
        (sender tx-sender)
        (fee-addr (unwrap! (var-get fee-recipient) ERR_NOT_INITIALIZED)))
    (asserts! (<= stacks-block-height deadline) ERR_DEADLINE_EXPIRED)
    (asserts! (> dx u0) ERR_ZERO_INPUT)
    (asserts! (and (> rx u0) (> ry u0)) ERR_ZERO_RESERVES)
    (let ((fee (/ (* dx FEE_BPS) BPS_DENOM))
          (dx-to-pool (- dx fee))
          (dy (/ (* ry dx-to-pool) (+ rx dx-to-pool))))
      (asserts! (>= dy min-dy) ERR_SLIPPAGE_EXCEEDED)
      (asserts! (< dy ry) ERR_INSUFFICIENT_LIQUIDITY)
      (if (and (> fee u0) (not (is-eq sender fee-addr)))
        (unwrap! (contract-call? token-x transfer fee sender fee-addr none) ERR_FEE_TRANSFER_FAILED)
        true)
      (unwrap! (contract-call? token-x transfer dx-to-pool sender (as-contract tx-sender) none) ERR_TRANSFER_X_FAILED)
      (unwrap! (as-contract (contract-call? token-y transfer dy tx-sender recipient none)) ERR_TRANSFER_Y_FAILED)
      (var-set reserve-x (+ rx dx-to-pool))
      (var-set reserve-y (- ry dy))
      (var-set total-fees-x (+ (var-get total-fees-x) fee))
      (ok { dx: dx, dy: dy, fee: fee, recipient: recipient }))))

(define-public (swap-y-for-x 
    (token-x <ft-trait>)
    (token-y <ft-trait>)
    (dy uint)
    (min-dx uint)
    (recipient principal)
    (deadline uint))
  (let ((rx (var-get reserve-x))
        (ry (var-get reserve-y))
        (sender tx-sender)
        (fee-addr (unwrap! (var-get fee-recipient) ERR_NOT_INITIALIZED)))
    (asserts! (<= stacks-block-height deadline) ERR_DEADLINE_EXPIRED)
    (asserts! (> dy u0) ERR_ZERO_INPUT)
    (asserts! (and (> rx u0) (> ry u0)) ERR_ZERO_RESERVES)
    (let ((fee (/ (* dy FEE_BPS) BPS_DENOM))
          (dy-to-pool (- dy fee))
          (dx (/ (* rx dy-to-pool) (+ ry dy-to-pool))))
      (asserts! (>= dx min-dx) ERR_SLIPPAGE_EXCEEDED)
      (asserts! (< dx rx) ERR_INSUFFICIENT_LIQUIDITY)
      (if (and (> fee u0) (not (is-eq sender fee-addr)))
        (unwrap! (contract-call? token-y transfer fee sender fee-addr none) ERR_FEE_TRANSFER_FAILED)
        true)
      (unwrap! (contract-call? token-y transfer dy-to-pool sender (as-contract tx-sender) none) ERR_TRANSFER_Y_FAILED)
      (unwrap! (as-contract (contract-call? token-x transfer dx tx-sender recipient none)) ERR_TRANSFER_X_FAILED)
      (var-set reserve-x (- rx dx))
      (var-set reserve-y (+ ry dy-to-pool))
      (var-set total-fees-y (+ (var-get total-fees-y) fee))
      (ok { dx: dx, dy: dy, fee: fee, recipient: recipient }))))

(define-public (initialize-pool 
    (token-x <ft-trait>)
    (token-y <ft-trait>)
    (amount-x uint)
    (amount-y uint))
  (let ((sender tx-sender))
    (asserts! (and (is-eq (var-get reserve-x) u0) (is-eq (var-get reserve-y) u0)) ERR_ALREADY_INITIALIZED)
    (asserts! (and (> amount-x u0) (> amount-y u0)) ERR_ZERO_INPUT)
    (let ((shares (sqrti (* amount-x amount-y))))
      (asserts! (> shares MINIMUM_LIQUIDITY) ERR_MIN_LIQUIDITY)
      (var-set fee-recipient (some sender))
      (unwrap! (contract-call? token-x transfer amount-x sender (as-contract tx-sender) none) ERR_TRANSFER_X_FAILED)
      (unwrap! (contract-call? token-y transfer amount-y sender (as-contract tx-sender) none) ERR_TRANSFER_Y_FAILED)
      (var-set reserve-x amount-x)
      (var-set reserve-y amount-y)
      (var-set total-supply shares)
      (map-set lp-balances sender shares)
      (ok { shares: shares, x: amount-x, y: amount-y }))))

(define-public (add-liquidity
    (token-x <ft-trait>)
    (token-y <ft-trait>)
    (amount-x uint)
    (amount-y uint)
    (min-shares uint))
  (let ((rx (var-get reserve-x))
        (ry (var-get reserve-y))
        (supply (var-get total-supply))
        (sender tx-sender))
    (asserts! (> supply u0) ERR_NOT_INITIALIZED)
    (asserts! (and (> amount-x u0) (> amount-y u0)) ERR_ZERO_INPUT)
    (let ((shares-from-x (/ (* amount-x supply) rx))
          (shares-from-y (/ (* amount-y supply) ry))
          (shares (if (< shares-from-x shares-from-y) shares-from-x shares-from-y))
          (actual-x (/ (* shares rx) supply))
          (actual-y (/ (* shares ry) supply)))
      (asserts! (>= shares min-shares) ERR_SLIPPAGE_EXCEEDED)
      (asserts! (> shares u0) ERR_ZERO_SHARES)
      (unwrap! (contract-call? token-x transfer actual-x sender (as-contract tx-sender) none) ERR_TRANSFER_X_FAILED)
      (unwrap! (contract-call? token-y transfer actual-y sender (as-contract tx-sender) none) ERR_TRANSFER_Y_FAILED)
      (var-set reserve-x (+ rx actual-x))
      (var-set reserve-y (+ ry actual-y))
      (var-set total-supply (+ supply shares))
      (map-set lp-balances sender (+ (get-lp-balance sender) shares))
      (ok { shares: shares, x: actual-x, y: actual-y }))))

(define-public (remove-liquidity
    (token-x <ft-trait>)
    (token-y <ft-trait>)
    (shares uint)
    (min-x uint)
    (min-y uint))
  (let ((rx (var-get reserve-x))
        (ry (var-get reserve-y))
        (supply (var-get total-supply))
        (sender tx-sender)
        (user-balance (get-lp-balance sender)))
    (asserts! (> supply u0) ERR_NOT_INITIALIZED)
    (asserts! (> shares u0) ERR_ZERO_INPUT)
    (asserts! (>= user-balance shares) ERR_INSUFFICIENT_LP_BALANCE)
    (let ((amount-x (/ (* shares rx) supply))
          (amount-y (/ (* shares ry) supply)))
      (asserts! (>= amount-x min-x) ERR_SLIPPAGE_EXCEEDED)
      (asserts! (>= amount-y min-y) ERR_SLIPPAGE_EXCEEDED)
      (unwrap! (as-contract (contract-call? token-x transfer amount-x tx-sender sender none)) ERR_TRANSFER_X_FAILED)
      (unwrap! (as-contract (contract-call? token-y transfer amount-y tx-sender sender none)) ERR_TRANSFER_Y_FAILED)
      (var-set reserve-x (- rx amount-x))
      (var-set reserve-y (- ry amount-y))
      (var-set total-supply (- supply shares))
      (map-set lp-balances sender (- user-balance shares))
      (ok { shares: shares, x: amount-x, y: amount-y }))))

(define-read-only (get-contract-info)
  { 
    name: "stacks-dex-pool-v4", 
    version: "4.0.0", 
    fee-bps: FEE_BPS, 
    fee-recipient: (var-get fee-recipient), 
    reserve-x: (var-get reserve-x), 
    reserve-y: (var-get reserve-y),
    total-supply: (var-get total-supply),
    total-fees-x: (var-get total-fees-x),
    total-fees-y: (var-get total-fees-y)
  })`;

    const statusEl = document.getElementById('status');
    const outputEl = document.getElementById('output');
    const deployBtn = document.getElementById('deployBtn');

    deployBtn.addEventListener('click', async function() {
      outputEl.textContent = 'Starting deployment...\n';
      
      if (!window.LeatherProvider) {
        statusEl.innerHTML = '<div class="status error">‚ùå Leather wallet not found</div>';
        return;
      }
      
      outputEl.textContent += '‚úì Leather wallet detected\n';

      try {
        const addressResponse = await window.LeatherProvider.request('getAddresses');
        const stacksAddress = addressResponse.result.addresses.find(function(a) {
          return a.type === 'stacks' || (a.address && (a.address.startsWith('SP') || a.address.startsWith('SM')));
        });

        const senderAddress = stacksAddress.address;
        outputEl.textContent += '‚úì Connected: ' + senderAddress + '\n\n';

        statusEl.innerHTML = '<div class="status pending">Please confirm contract deployment in Leather...</div>';

        const deployResponse = await window.LeatherProvider.request('stx_deployContract', {
          name: 'pool-v4',
          clarityCode: CONTRACT_SOURCE,
          clarityVersion: '3',
          network: 'mainnet',
          fee: 600000,
        });

        if (deployResponse.result && deployResponse.result.txid) {
          const txId = deployResponse.result.txid;
          statusEl.innerHTML = '<div class="status success">‚úÖ Contract deployment submitted!</div>';
          outputEl.textContent += '‚úÖ SUCCESS!\n';
          outputEl.textContent += 'Transaction ID: ' + txId + '\n';
          outputEl.textContent += 'Contract: ' + senderAddress + '.pool-v4\n\n';
          outputEl.textContent += 'View: https://explorer.hiro.so/txid/' + txId + '?chain=mainnet\n\n';
          outputEl.textContent += '‚è≥ Wait for confirmation, then initialize the pool.';
        }
      } catch (error) {
        console.error('Deploy error:', error);
        statusEl.innerHTML = '<div class="status error">Error: ' + (error.message || 'Unknown') + '</div>';
        outputEl.textContent += '‚ùå Error: ' + (error.message || JSON.stringify(error)) + '\n';
      }
    });
  </script>
</body>
</html>
